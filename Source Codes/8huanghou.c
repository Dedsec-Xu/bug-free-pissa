#include "stdio.h" #include "string.h" #include "algorithm" using namespace std; int n,sum,vis[3][50],a[15]; void dfs(int cur) //逐行递增 { int i; if(cur==n+1) //这里是n+1不是n sum++; else for(i=1;i<=n;i++) { if(!vis[0][i]&&!vis[1][cur+i]&&!vis[2][cur+n-i]) //分别代表列、主对角线、副对角线 { vis[0][i]=vis[1][cur+i]=vis[2][cur+n-i]=1; dfs(cur+1); vis[0][i]=vis[1][cur+i]=vis[2][cur+n-i]=0; } } } int main(int argc, char const *argv[]) { for(n=1;n<=10;n++) //提前打表以防超时 { memset(vis,0,sizeof(vis)); sum=0; dfs(1); a[n]=sum; } while(scanf("%d",&n),n) { printf("%d\n",a[n]); } return 0; } 前两天在知乎上看到大神发的十行的八皇后代码（貌似发在这上面就超了），标准库用的太精髓了。贴一下吧，日后再研究。。。 #include <iostream> #include <algorithm> #include <bitset> #include <numeric> #include <utility> int main() { for (int queens[] = {0,1,2,3,4,5,6,7}; ::std::next_permutation(queens,queens+8); ) if ((::std::bitset<15>(::std::accumulate(queens,queens+8, ::std::make_pair(0, 0), [](::std::pair<int, int> a, int b){return ::std::make_pair((1<<(b+a.second))|a.first,a.second+1);}).first).count() == 8) && (::std::bitset<15>(::std::accumulate(queens, queens+8, ::std::make_pair(0, 0), [](::std::pair<int, int> a, int b){return ::std::make_pair((1<<(7+b-a.second))|a.first, a.second+1);}).first).count() == 8)) ::std::cout << queens[0] << queens[1] << queens[2] << queens[3] << queens[4] << queens[5] << queens[6] << queens[7] << ::std::endl; }
